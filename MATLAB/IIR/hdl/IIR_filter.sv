// -------------------------------------------------------------
//
// Module: IIR_filter
// Generated by MATLAB(R) 9.5 and Filter Design HDL Coder 3.1.4.
// Generated on: 2021-11-12 16:36:04
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Code Generation Options:
//
// InputType: signed/unsigned
// ClockEnableInputPort: i_clk_enable
// ClockInputPort: i_clk
// ResetInputPort: i_reset
// TargetDirectory: D:\Yehor\FPGA_Development\FPGA_digital_filters\MATLAB\IIR\hdl
// InputPort: i_filter_data
// OutputPort: o_filter_data
// Name: IIR_filter
// ResetAssertedLevel: Active-low
// TargetLanguage: Verilog
// TestBenchStimulus: step ramp chirp 
// InlineConfigurations: off

// Filter Specifications:
//
// Sample Rate   : N/A (normalized frequency)
// Response      : Lowpass
// Specification : N,F3dB
// Filter Order  : 4
// 3-dB Point    : 0.12
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Implementation    : Fully parallel
// Folding Factor        : 1
// -------------------------------------------------------------
// Filter Settings:
//
// Discrete-Time IIR Filter (real)
// -------------------------------
// Filter Structure    : Direct-Form II, Second-Order Sections
// Number of Sections  : 2
// Stable              : Yes
// Linear Phase        : No
// Arithmetic          : fixed
// Numerator           : s16,13 -> [-4 4)
// Denominator         : s16,14 -> [-2 2)
// Scale Values        : s16,20 -> [-3.125000e-02 3.125000e-02)
// Input               : s16,15 -> [-1 1)
// Section Input       : s32,30 -> [-2 2)
// Section Output      : s32,26 -> [-32 32)
// Output              : s32,26 -> [-32 32)
// State               : s32,31 -> [-1 1)
// Numerator Prod      : s48,44 -> [-8 8)
// Denominator Prod    : s48,45 -> [-4 4)
// Numerator Accum     : s40,34 -> [-32 32)
// Denominator Accum   : s40,35 -> [-16 16)
// Round Mode          : floor
// Overflow Mode       : saturate
// Cast Before Sum     : true
// -------------------------------------------------------------




`timescale 1 ns / 1 ns

module IIR_filter
               (
                i_clk,
                i_clk_enable,
                i_reset,
                i_filter_data,
                o_filter_data
                );

  input   i_clk; 
  input   i_clk_enable; 
  input   i_reset; 
  input   signed [15:0] i_filter_data; //sfix16_En15
  output  signed [31:0] o_filter_data; //sfix32_En26

////////////////////////////////////////////////////////////////
//Module Architecture: IIR_filter
////////////////////////////////////////////////////////////////
  // Local Functions
  // Type Definitions
  // Constants
  parameter signed [28:0] scaleconst1 = 29'b00000000000000111111000001111; //sfix29_En20
  parameter signed [28:0] coeff_b1_section1 = 29'b00000000100000000000000000000; //sfix29_En20
  parameter signed [28:0] coeff_b2_section1 = 29'b00000001000000000000000000000; //sfix29_En20
  parameter signed [28:0] coeff_b3_section1 = 29'b00000000100000000000000000000; //sfix29_En20
  parameter signed [28:0] coeff_a2_section1 = 29'b11111111001011110101111000000; //sfix29_En20
  parameter signed [28:0] coeff_a3_section1 = 29'b00000000011000000110010000000; //sfix29_En20
  parameter signed [28:0] scaleconst2 = 29'b00000000000000110101101010010; //sfix29_En20
  parameter signed [28:0] coeff_b1_section2 = 29'b00000000100000000000000000000; //sfix29_En20
  parameter signed [28:0] coeff_b2_section2 = 29'b00000001000000000000000000000; //sfix29_En20
  parameter signed [28:0] coeff_b3_section2 = 29'b00000000100000000000000000000; //sfix29_En20
  parameter signed [28:0] coeff_a2_section2 = 29'b11111111010011100110001000000; //sfix29_En20
  parameter signed [28:0] coeff_a3_section2 = 29'b00000000001111110000100000000; //sfix29_En20
  // Signals
  reg  signed [15:0] input_register; // sfix16_En15
  wire signed [60:0] scale1; // sfix61_En46
  wire signed [44:0] mul_temp; // sfix45_En35
  wire signed [31:0] scaletypeconvert1; // sfix32_En30
  // Section 1 Signals 
  wire signed [39:0] a1sum1; // sfix40_En35
  wire signed [39:0] a2sum1; // sfix40_En35
  wire signed [39:0] b1sum1; // sfix40_En34
  wire signed [39:0] b2sum1; // sfix40_En34
  wire signed [31:0] typeconvert1; // sfix32_En31
  reg  signed [31:0] delay_section1 [0:1] ; // sfix32_En31
  wire signed [39:0] inputconv1; // sfix40_En35
  wire signed [47:0] a2mul1; // sfix48_En45
  wire signed [47:0] a3mul1; // sfix48_En45
  wire signed [47:0] b1mul1; // sfix48_En44
  wire signed [47:0] b2mul1; // sfix48_En44
  wire signed [47:0] b3mul1; // sfix48_En44
  wire signed [60:0] mul_temp_1; // sfix61_En51
  wire signed [60:0] mul_temp_2; // sfix61_En51
  wire signed [39:0] sub_cast; // sfix40_En35
  wire signed [39:0] sub_cast_1; // sfix40_En35
  wire signed [40:0] sub_temp; // sfix41_En35
  wire signed [39:0] sub_cast_2; // sfix40_En35
  wire signed [39:0] sub_cast_3; // sfix40_En35
  wire signed [40:0] sub_temp_1; // sfix41_En35
  wire signed [39:0] b1multypeconvert1; // sfix40_En34
  wire signed [39:0] add_cast; // sfix40_En34
  wire signed [39:0] add_cast_1; // sfix40_En34
  wire signed [40:0] add_temp; // sfix41_En34
  wire signed [39:0] add_cast_2; // sfix40_En34
  wire signed [39:0] add_cast_3; // sfix40_En34
  wire signed [40:0] add_temp_1; // sfix41_En34
  wire signed [31:0] section_result1; // sfix32_En26
  wire signed [60:0] scale2; // sfix61_En46
  wire signed [31:0] scaletypeconvert2; // sfix32_En30
  // Section 2 Signals 
  wire signed [39:0] a1sum2; // sfix40_En35
  wire signed [39:0] a2sum2; // sfix40_En35
  wire signed [39:0] b1sum2; // sfix40_En34
  wire signed [39:0] b2sum2; // sfix40_En34
  wire signed [31:0] typeconvert2; // sfix32_En31
  reg  signed [31:0] delay_section2 [0:1] ; // sfix32_En31
  wire signed [39:0] inputconv2; // sfix40_En35
  wire signed [47:0] a2mul2; // sfix48_En45
  wire signed [47:0] a3mul2; // sfix48_En45
  wire signed [47:0] b1mul2; // sfix48_En44
  wire signed [47:0] b2mul2; // sfix48_En44
  wire signed [47:0] b3mul2; // sfix48_En44
  wire signed [60:0] mul_temp_3; // sfix61_En51
  wire signed [60:0] mul_temp_4; // sfix61_En51
  wire signed [39:0] sub_cast_4; // sfix40_En35
  wire signed [39:0] sub_cast_5; // sfix40_En35
  wire signed [40:0] sub_temp_2; // sfix41_En35
  wire signed [39:0] sub_cast_6; // sfix40_En35
  wire signed [39:0] sub_cast_7; // sfix40_En35
  wire signed [40:0] sub_temp_3; // sfix41_En35
  wire signed [39:0] b1multypeconvert2; // sfix40_En34
  wire signed [39:0] add_cast_4; // sfix40_En34
  wire signed [39:0] add_cast_5; // sfix40_En34
  wire signed [40:0] add_temp_2; // sfix41_En34
  wire signed [39:0] add_cast_6; // sfix40_En34
  wire signed [39:0] add_cast_7; // sfix40_En34
  wire signed [40:0] add_temp_3; // sfix41_En34
  wire signed [31:0] output_typeconvert; // sfix32_En26
  reg  signed [31:0] output_register; // sfix32_En26

  // Block Statements
  always @ (posedge i_clk or negedge i_reset)
    begin: input_reg_process
      if (i_reset == 1'b0) begin
        input_register <= 0;
      end
      else begin
        if (i_clk_enable == 1'b1) begin
          input_register <= i_filter_data;
        end
      end
    end // input_reg_process

  assign mul_temp = input_register * scaleconst1;
  assign scale1 = $signed({mul_temp, 11'b00000000000});

  assign scaletypeconvert1 = (scale1[60] == 1'b0 & scale1[59:47] != 13'b0000000000000) ? 32'b01111111111111111111111111111111 : 
      (scale1[60] == 1'b1 && scale1[59:47] != 13'b1111111111111) ? 32'b10000000000000000000000000000000 : scale1[47:16];

  //   ------------------ Section 1 ------------------

  assign typeconvert1 = (a1sum1[39] == 1'b0 & a1sum1[38:35] != 4'b0000) ? 32'b01111111111111111111111111111111 : 
      (a1sum1[39] == 1'b1 && a1sum1[38:35] != 4'b1111) ? 32'b10000000000000000000000000000000 : a1sum1[35:4];

  always @ (posedge i_clk or negedge i_reset)
    begin: delay_process_section1
      if (i_reset == 1'b0) begin
        delay_section1[0] <= 32'h00000000;
        delay_section1[1] <= 32'h00000000;
      end
      else begin
        if (i_clk_enable == 1'b1) begin
          delay_section1[1] <= delay_section1[0];
          delay_section1[0] <= typeconvert1;
        end
      end
    end // delay_process_section1

  assign inputconv1 = $signed({scaletypeconvert1, 5'b00000});

  assign mul_temp_1 = delay_section1[0] * coeff_a2_section1;
  assign a2mul1 = (mul_temp_1[60] == 1'b0 & mul_temp_1[59:53] != 7'b0000000) ? 48'b011111111111111111111111111111111111111111111111 : 
      (mul_temp_1[60] == 1'b1 && mul_temp_1[59:53] != 7'b1111111) ? 48'b100000000000000000000000000000000000000000000000 : mul_temp_1[53:6];

  assign mul_temp_2 = delay_section1[1] * coeff_a3_section1;
  assign a3mul1 = (mul_temp_2[60] == 1'b0 & mul_temp_2[59:53] != 7'b0000000) ? 48'b011111111111111111111111111111111111111111111111 : 
      (mul_temp_2[60] == 1'b1 && mul_temp_2[59:53] != 7'b1111111) ? 48'b100000000000000000000000000000000000000000000000 : mul_temp_2[53:6];

  assign b1mul1 = $signed({typeconvert1, 13'b0000000000000});

  assign b2mul1 = $signed({delay_section1[0], 14'b00000000000000});

  assign b3mul1 = $signed({delay_section1[1], 13'b0000000000000});

  assign sub_cast = inputconv1;
  assign sub_cast_1 = $signed({{2{a2mul1[47]}}, a2mul1[47:10]});
  assign sub_temp = sub_cast - sub_cast_1;
  assign a2sum1 = (sub_temp[40] == 1'b0 & sub_temp[39] != 1'b0) ? 40'b0111111111111111111111111111111111111111 : 
      (sub_temp[40] == 1'b1 && sub_temp[39] != 1'b1) ? 40'b1000000000000000000000000000000000000000 : sub_temp[39:0];

  assign sub_cast_2 = a2sum1;
  assign sub_cast_3 = $signed({{2{a3mul1[47]}}, a3mul1[47:10]});
  assign sub_temp_1 = sub_cast_2 - sub_cast_3;
  assign a1sum1 = (sub_temp_1[40] == 1'b0 & sub_temp_1[39] != 1'b0) ? 40'b0111111111111111111111111111111111111111 : 
      (sub_temp_1[40] == 1'b1 && sub_temp_1[39] != 1'b1) ? 40'b1000000000000000000000000000000000000000 : sub_temp_1[39:0];

  assign b1multypeconvert1 = $signed({{2{b1mul1[47]}}, b1mul1[47:10]});

  assign add_cast = b1multypeconvert1;
  assign add_cast_1 = $signed({{2{b2mul1[47]}}, b2mul1[47:10]});
  assign add_temp = add_cast + add_cast_1;
  assign b2sum1 = (add_temp[40] == 1'b0 & add_temp[39] != 1'b0) ? 40'b0111111111111111111111111111111111111111 : 
      (add_temp[40] == 1'b1 && add_temp[39] != 1'b1) ? 40'b1000000000000000000000000000000000000000 : add_temp[39:0];

  assign add_cast_2 = b2sum1;
  assign add_cast_3 = $signed({{2{b3mul1[47]}}, b3mul1[47:10]});
  assign add_temp_1 = add_cast_2 + add_cast_3;
  assign b1sum1 = (add_temp_1[40] == 1'b0 & add_temp_1[39] != 1'b0) ? 40'b0111111111111111111111111111111111111111 : 
      (add_temp_1[40] == 1'b1 && add_temp_1[39] != 1'b1) ? 40'b1000000000000000000000000000000000000000 : add_temp_1[39:0];

  assign section_result1 = b1sum1[39:8];

  assign scale2 = section_result1 * scaleconst2;

  assign scaletypeconvert2 = (scale2[60] == 1'b0 & scale2[59:47] != 13'b0000000000000) ? 32'b01111111111111111111111111111111 : 
      (scale2[60] == 1'b1 && scale2[59:47] != 13'b1111111111111) ? 32'b10000000000000000000000000000000 : scale2[47:16];

  //   ------------------ Section 2 ------------------

  assign typeconvert2 = (a1sum2[39] == 1'b0 & a1sum2[38:35] != 4'b0000) ? 32'b01111111111111111111111111111111 : 
      (a1sum2[39] == 1'b1 && a1sum2[38:35] != 4'b1111) ? 32'b10000000000000000000000000000000 : a1sum2[35:4];

  always @ (posedge i_clk or negedge i_reset)
    begin: delay_process_section2
      if (i_reset == 1'b0) begin
        delay_section2[0] <= 32'h00000000;
        delay_section2[1] <= 32'h00000000;
      end
      else begin
        if (i_clk_enable == 1'b1) begin
          delay_section2[1] <= delay_section2[0];
          delay_section2[0] <= typeconvert2;
        end
      end
    end // delay_process_section2

  assign inputconv2 = $signed({scaletypeconvert2, 5'b00000});

  assign mul_temp_3 = delay_section2[0] * coeff_a2_section2;
  assign a2mul2 = (mul_temp_3[60] == 1'b0 & mul_temp_3[59:53] != 7'b0000000) ? 48'b011111111111111111111111111111111111111111111111 : 
      (mul_temp_3[60] == 1'b1 && mul_temp_3[59:53] != 7'b1111111) ? 48'b100000000000000000000000000000000000000000000000 : mul_temp_3[53:6];

  assign mul_temp_4 = delay_section2[1] * coeff_a3_section2;
  assign a3mul2 = (mul_temp_4[60] == 1'b0 & mul_temp_4[59:53] != 7'b0000000) ? 48'b011111111111111111111111111111111111111111111111 : 
      (mul_temp_4[60] == 1'b1 && mul_temp_4[59:53] != 7'b1111111) ? 48'b100000000000000000000000000000000000000000000000 : mul_temp_4[53:6];

  assign b1mul2 = $signed({typeconvert2, 13'b0000000000000});

  assign b2mul2 = $signed({delay_section2[0], 14'b00000000000000});

  assign b3mul2 = $signed({delay_section2[1], 13'b0000000000000});

  assign sub_cast_4 = inputconv2;
  assign sub_cast_5 = $signed({{2{a2mul2[47]}}, a2mul2[47:10]});
  assign sub_temp_2 = sub_cast_4 - sub_cast_5;
  assign a2sum2 = (sub_temp_2[40] == 1'b0 & sub_temp_2[39] != 1'b0) ? 40'b0111111111111111111111111111111111111111 : 
      (sub_temp_2[40] == 1'b1 && sub_temp_2[39] != 1'b1) ? 40'b1000000000000000000000000000000000000000 : sub_temp_2[39:0];

  assign sub_cast_6 = a2sum2;
  assign sub_cast_7 = $signed({{2{a3mul2[47]}}, a3mul2[47:10]});
  assign sub_temp_3 = sub_cast_6 - sub_cast_7;
  assign a1sum2 = (sub_temp_3[40] == 1'b0 & sub_temp_3[39] != 1'b0) ? 40'b0111111111111111111111111111111111111111 : 
      (sub_temp_3[40] == 1'b1 && sub_temp_3[39] != 1'b1) ? 40'b1000000000000000000000000000000000000000 : sub_temp_3[39:0];

  assign b1multypeconvert2 = $signed({{2{b1mul2[47]}}, b1mul2[47:10]});

  assign add_cast_4 = b1multypeconvert2;
  assign add_cast_5 = $signed({{2{b2mul2[47]}}, b2mul2[47:10]});
  assign add_temp_2 = add_cast_4 + add_cast_5;
  assign b2sum2 = (add_temp_2[40] == 1'b0 & add_temp_2[39] != 1'b0) ? 40'b0111111111111111111111111111111111111111 : 
      (add_temp_2[40] == 1'b1 && add_temp_2[39] != 1'b1) ? 40'b1000000000000000000000000000000000000000 : add_temp_2[39:0];

  assign add_cast_6 = b2sum2;
  assign add_cast_7 = $signed({{2{b3mul2[47]}}, b3mul2[47:10]});
  assign add_temp_3 = add_cast_6 + add_cast_7;
  assign b1sum2 = (add_temp_3[40] == 1'b0 & add_temp_3[39] != 1'b0) ? 40'b0111111111111111111111111111111111111111 : 
      (add_temp_3[40] == 1'b1 && add_temp_3[39] != 1'b1) ? 40'b1000000000000000000000000000000000000000 : add_temp_3[39:0];

  assign output_typeconvert = b1sum2[39:8];

  always @ (posedge i_clk or negedge i_reset)
    begin: Output_Register_process
      if (i_reset == 1'b0) begin
        output_register <= 0;
      end
      else begin
        if (i_clk_enable == 1'b1) begin
          output_register <= output_typeconvert;
        end
      end
    end // Output_Register_process

  // Assignment Statements
  assign o_filter_data = output_register;
endmodule  // IIR_filter

// -------------------------------------------------------------
//
// Module: IIR_filter
// Generated by MATLAB(R) 9.5 and Filter Design HDL Coder 3.1.4.
// Generated on: 2021-11-12 14:15:36
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Code Generation Options:
//
// FoldingFactor: 12
// ClockEnableInputPort: i_clk_enable
// ClockInputPort: i_clk
// ResetInputPort: i_reset
// TargetDirectory: D:\Yehor\FPGA_Development\FPGA_digital_filters\MATLAB\IIR\hdl
// InputPort: i_filter_data
// OutputPort: o_filter_data
// Name: IIR_filter
// ResetAssertedLevel: Active-low
// TargetLanguage: Verilog
// TestBenchStimulus: step ramp chirp 
// ClockHighTime: 1000
// ClockLowTime: 1000

// Filter Specifications:
//
// Sample Rate   : N/A (normalized frequency)
// Response      : Lowpass
// Specification : N,F3dB
// Filter Order  : 4
// 3-dB Point    : 0.12
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Implementation    : Fully Serial
// Folding Factor        : 12
// -------------------------------------------------------------
// Filter Settings:
//
// Discrete-Time IIR Filter (real)
// -------------------------------
// Filter Structure    : Direct-Form II, Second-Order Sections
// Number of Sections  : 2
// Stable              : Yes
// Linear Phase        : No
// Arithmetic          : fixed
// Numerator           : s16,13 -> [-4 4)
// Denominator         : s16,14 -> [-2 2)
// Scale Values        : s16,20 -> [-3.125000e-02 3.125000e-02)
// Input               : s16,15 -> [-1 1)
// Section Input       : s32,31 -> [-1 1)
// Section Output      : s32,31 -> [-1 1)
// Output              : s32,31 -> [-1 1)
// State               : s32,31 -> [-1 1)
// Numerator Prod      : s48,44 -> [-8 8)
// Denominator Prod    : s48,45 -> [-4 4)
// Numerator Accum     : s40,34 -> [-32 32)
// Denominator Accum   : s40,35 -> [-16 16)
// Round Mode          : floor
// Overflow Mode       : saturate
// Cast Before Sum     : true
// -------------------------------------------------------------




`timescale 1 ns / 1 ns

module IIR_filter
               (
                i_clk,
                i_clk_enable,
                i_reset,
                i_filter_data,
                o_filter_data
                );

  input   i_clk; 
  input   i_clk_enable; 
  input   i_reset; 
  input   signed [15:0] i_filter_data; //sfix16_En15
  output  signed [31:0] o_filter_data; //sfix32_En31

////////////////////////////////////////////////////////////////
//Module Architecture: IIR_filter
////////////////////////////////////////////////////////////////
  // Local Functions
  // Type Definitions
  // Constants
  parameter signed [28:0] scaleconst1 = 29'b00000000000000111111000001111; //sfix29_En20
  parameter signed [28:0] coeff_b1_section1 = 29'b00000000100000000000000000000; //sfix29_En20
  parameter signed [28:0] coeff_b2_section1 = 29'b00000001000000000000000000000; //sfix29_En20
  parameter signed [28:0] coeff_b3_section1 = 29'b00000000100000000000000000000; //sfix29_En20
  parameter signed [28:0] coeff_a2_section1 = 29'b11111111001011110101111000000; //sfix29_En20
  parameter signed [28:0] coeff_a3_section1 = 29'b00000000011000000110010000000; //sfix29_En20
  parameter signed [28:0] scaleconst2 = 29'b00000000000000110101101010010; //sfix29_En20
  parameter signed [28:0] coeff_b1_section2 = 29'b00000000100000000000000000000; //sfix29_En20
  parameter signed [28:0] coeff_b2_section2 = 29'b00000001000000000000000000000; //sfix29_En20
  parameter signed [28:0] coeff_b3_section2 = 29'b00000000100000000000000000000; //sfix29_En20
  parameter signed [28:0] coeff_a2_section2 = 29'b11111111010011100110001000000; //sfix29_En20
  parameter signed [28:0] coeff_a3_section2 = 29'b00000000001111110000100000000; //sfix29_En20
  // Signals
  reg  signed [15:0] input_register; // sfix16_En15
  reg  [3:0] cur_count; // ufix4
  wire phase_0; // boolean
  wire phase_2; // boolean
  wire phase_3; // boolean
  wire phase_5; // boolean
  wire phase_6; // boolean
  wire phase_8; // boolean
  wire phase_9; // boolean
  wire phase_11; // boolean
  wire signed [31:0] sectionipconvert; // sfix32_En31
  wire signed [31:0] storagetypeconvert; // sfix32_En31
  reg  signed [31:0] prev_stg_op1; // sfix32_En31
  reg  signed [31:0] storage_state_in1; // sfix32_En31
  reg  signed [31:0] delay_section1 [0:1] ; // sfix32_En31
  reg  signed [31:0] storage_state_in2; // sfix32_En31
  reg  signed [31:0] delay_section2 [0:1] ; // sfix32_En31
  wire signed [31:0] input_section1_cast; // sfix32_En31
  wire signed [31:0] storage_in_section1_cast; // sfix32_En31
  wire signed [31:0] delay_section11_cast; // sfix32_En31
  wire signed [31:0] delay_section12_cast; // sfix32_En31
  wire signed [31:0] input_section2_cast; // sfix32_En31
  wire signed [31:0] storage_in_section2_cast; // sfix32_En31
  wire signed [31:0] delay_section21_cast; // sfix32_En31
  wire signed [31:0] delay_section22_cast; // sfix32_En31
  wire signed [31:0] inputmux_section_1; // sfix32_En31
  wire signed [28:0] coeffmux_section_1; // sfix29_En20
  wire signed [60:0] prod; // sfix61_En51
  wire signed [47:0] prod_den; // sfix48_En45
  wire signed [39:0] prod_den_cast_temp; // sfix40_En35
  wire signed [40:0] prod_den_cast; // sfix41_En35
  wire signed [40:0] prod_den_cast_neg; // sfix41_En35
  wire signed [41:0] unaryminus_temp; // sfix42_En35
  wire signed [47:0] prod_num; // sfix48_En44
  wire signed [39:0] prod_num_cast_temp; // sfix40_En34
  wire signed [40:0] prod_num_cast; // sfix41_En35
  wire signed [40:0] accum_mux_in1; // sfix41_En35
  wire signed [40:0] accum_mux_in2; // sfix41_En35
  wire signed [40:0] acc_sum; // sfix41_En35
  wire signed [39:0] sum_den; // sfix40_En35
  wire signed [40:0] sum_den_cast; // sfix41_En35
  wire signed [39:0] sum_num; // sfix40_En34
  wire signed [40:0] sum_num_cast; // sfix41_En35
  wire signed [40:0] accum_mux_out; // sfix41_En35
  wire signed [40:0] accum_mux_in1_temp; // sfix41_En35
  wire signed [40:0] sectionipconvert_cast; // sfix41_En35
  wire final_phase; // boolean
  wire section_phase; // boolean
  reg  signed [40:0] accum_reg; // sfix41_En35
  wire signed [40:0] add_cast; // sfix41_En35
  wire signed [40:0] add_cast_1; // sfix41_En35
  wire signed [41:0] add_temp; // sfix42_En35
  wire signed [39:0] acc_out_cast_numacc; // sfix40_En34
  wire signed [31:0] sectionopconvert; // sfix32_En31
  wire signed [31:0] output_typeconvert; // sfix32_En31
  reg  signed [31:0] output_register; // sfix32_En31

  // Block Statements
  always @ (posedge i_clk or negedge i_reset)
    begin: input_reg_process
      if (i_reset == 1'b0) begin
        input_register <= 0;
      end
      else begin
        if (i_clk_enable == 1'b1) begin
          input_register <= i_filter_data;
        end
      end
    end // input_reg_process

  always @ (posedge i_clk or negedge i_reset)
    begin: Counter_process
      if (i_reset == 1'b0) begin
        cur_count <= 4'b0000;
      end
      else begin
        if (i_clk_enable == 1'b1) begin
          if (cur_count >= 4'b1011) begin
            cur_count <= 4'b0000;
          end
          else begin
            cur_count <= cur_count + 4'b0001;
          end
        end
      end
    end // Counter_process

  assign  phase_0 = (cur_count == 4'b0000 && i_clk_enable == 1'b1) ? 1'b1 : 1'b0;

  assign  phase_2 = (cur_count == 4'b0010 && i_clk_enable == 1'b1) ? 1'b1 : 1'b0;

  assign  phase_3 = (cur_count == 4'b0011 && i_clk_enable == 1'b1) ? 1'b1 : 1'b0;

  assign  phase_5 = (cur_count == 4'b0101 && i_clk_enable == 1'b1) ? 1'b1 : 1'b0;

  assign  phase_6 = (cur_count == 4'b0110 && i_clk_enable == 1'b1) ? 1'b1 : 1'b0;

  assign  phase_8 = (cur_count == 4'b1000 && i_clk_enable == 1'b1) ? 1'b1 : 1'b0;

  assign  phase_9 = (cur_count == 4'b1001 && i_clk_enable == 1'b1) ? 1'b1 : 1'b0;

  assign  phase_11 = (cur_count == 4'b1011 && i_clk_enable == 1'b1) ? 1'b1 : 1'b0;


  // Next stage input = Previous stage output. Storing Previous stage output
  always @ (posedge i_clk or negedge i_reset)
    begin: prev_stg_op1_process
      if (i_reset == 1'b0) begin
        prev_stg_op1 <= 0;
      end
      else begin
        if (phase_5 == 1'b1) begin
          prev_stg_op1 <= sectionopconvert;
        end
      end
    end // prev_stg_op1_process

  always @ (posedge i_clk or negedge i_reset)
    begin: delay_process_section1
      if (i_reset == 1'b0) begin
        delay_section1[0] <= 32'h00000000;
        delay_section1[1] <= 32'h00000000;
      end
      else begin
        if (phase_0 == 1'b1) begin
          delay_section1[1] <= delay_section1[0];
          delay_section1[0] <= storage_state_in1;
        end
      end
    end // delay_process_section1

  always @ (posedge i_clk or negedge i_reset)
    begin: delay_process_section2
      if (i_reset == 1'b0) begin
        delay_section2[0] <= 32'h00000000;
        delay_section2[1] <= 32'h00000000;
      end
      else begin
        if (phase_0 == 1'b1) begin
          delay_section2[1] <= delay_section2[0];
          delay_section2[0] <= storage_state_in2;
        end
      end
    end // delay_process_section2

  // Making common precision for input and state 
  assign input_section1_cast = $signed({input_register, 16'b0000000000000000});

  assign delay_section11_cast = delay_section1[0];

  assign delay_section12_cast = delay_section1[1];

  assign storage_in_section1_cast = storage_state_in1;

  assign input_section2_cast = prev_stg_op1;

  assign delay_section21_cast = delay_section2[0];

  assign delay_section22_cast = delay_section2[1];

  assign storage_in_section2_cast = storage_state_in2;

  assign inputmux_section_1 = (cur_count == 4'b0000) ? input_section1_cast :
                             (cur_count == 4'b0001) ? delay_section11_cast :
                             (cur_count == 4'b0010) ? delay_section12_cast :
                             (cur_count == 4'b0011) ? storage_in_section1_cast :
                             (cur_count == 4'b0100) ? delay_section11_cast :
                             (cur_count == 4'b0101) ? delay_section12_cast :
                             (cur_count == 4'b0110) ? input_section2_cast :
                             (cur_count == 4'b0111) ? delay_section21_cast :
                             (cur_count == 4'b1000) ? delay_section22_cast :
                             (cur_count == 4'b1001) ? storage_in_section2_cast :
                             (cur_count == 4'b1010) ? delay_section21_cast :
                             delay_section22_cast;

  assign coeffmux_section_1 = (cur_count == 4'b0000) ? scaleconst1 :
                             (cur_count == 4'b0001) ? coeff_a2_section1 :
                             (cur_count == 4'b0010) ? coeff_a3_section1 :
                             (cur_count == 4'b0011) ? coeff_b1_section1 :
                             (cur_count == 4'b0100) ? coeff_b2_section1 :
                             (cur_count == 4'b0101) ? coeff_b3_section1 :
                             (cur_count == 4'b0110) ? scaleconst2 :
                             (cur_count == 4'b0111) ? coeff_a2_section2 :
                             (cur_count == 4'b1000) ? coeff_a3_section2 :
                             (cur_count == 4'b1001) ? coeff_b1_section2 :
                             (cur_count == 4'b1010) ? coeff_b2_section2 :
                             coeff_b3_section2;

  assign prod = inputmux_section_1 * coeffmux_section_1;

  assign prod_den = (prod[60] == 1'b0 & prod[59:53] != 7'b0000000) ? 48'b011111111111111111111111111111111111111111111111 : 
      (prod[60] == 1'b1 && prod[59:53] != 7'b1111111) ? 48'b100000000000000000000000000000000000000000000000 : prod[53:6];

  assign prod_den_cast_temp = $signed({{2{prod_den[47]}}, prod_den[47:10]});

  assign prod_den_cast = $signed({{1{prod_den_cast_temp[39]}}, prod_den_cast_temp});

  assign unaryminus_temp = (prod_den_cast==41'b10000000000000000000000000000000000000000) ? $signed({1'b0, prod_den_cast}) : -prod_den_cast;
  assign prod_den_cast_neg = (unaryminus_temp[41] == 1'b0 & unaryminus_temp[40] != 1'b0) ? 41'b01111111111111111111111111111111111111111 : 
      (unaryminus_temp[41] == 1'b1 && unaryminus_temp[40] != 1'b1) ? 41'b10000000000000000000000000000000000000000 : unaryminus_temp[40:0];

  assign prod_num = (prod[60] == 1'b0 & prod[59:54] != 6'b000000) ? 48'b011111111111111111111111111111111111111111111111 : 
      (prod[60] == 1'b1 && prod[59:54] != 6'b111111) ? 48'b100000000000000000000000000000000000000000000000 : prod[54:7];

  assign prod_num_cast_temp = $signed({{2{prod_num[47]}}, prod_num[47:10]});

  assign prod_num_cast = $signed({prod_num_cast_temp, 1'b0});

  assign accum_mux_in1 = (cur_count == 4'b0000) ? prod_num_cast :
                        (cur_count == 4'b0001) ? prod_den_cast_neg :
                        (cur_count == 4'b0010) ? prod_den_cast_neg :
                        (cur_count == 4'b0011) ? prod_num_cast :
                        (cur_count == 4'b0100) ? prod_num_cast :
                        (cur_count == 4'b0101) ? prod_num_cast :
                        (cur_count == 4'b0110) ? prod_num_cast :
                        (cur_count == 4'b0111) ? prod_den_cast_neg :
                        (cur_count == 4'b1000) ? prod_den_cast_neg :
                        (cur_count == 4'b1001) ? prod_num_cast :
                        (cur_count == 4'b1010) ? prod_num_cast :
                        prod_num_cast;

  assign sum_den = (acc_sum[40] == 1'b0 & acc_sum[39] != 1'b0) ? 40'b0111111111111111111111111111111111111111 : 
      (acc_sum[40] == 1'b1 && acc_sum[39] != 1'b1) ? 40'b1000000000000000000000000000000000000000 : acc_sum[39:0];

  assign sum_den_cast = $signed({{1{sum_den[39]}}, sum_den});

  assign sum_num = acc_sum[40:1];

  assign sum_num_cast = $signed({sum_num, 1'b0});

  assign accum_mux_in2 = (cur_count == 4'b0000) ? sum_num_cast :
                        (cur_count == 4'b0001) ? sum_den_cast :
                        (cur_count == 4'b0010) ? sum_den_cast :
                        (cur_count == 4'b0011) ? sum_num_cast :
                        (cur_count == 4'b0100) ? sum_num_cast :
                        (cur_count == 4'b0101) ? sum_num_cast :
                        (cur_count == 4'b0110) ? sum_num_cast :
                        (cur_count == 4'b0111) ? sum_den_cast :
                        (cur_count == 4'b1000) ? sum_den_cast :
                        (cur_count == 4'b1001) ? sum_num_cast :
                        (cur_count == 4'b1010) ? sum_num_cast :
                        sum_num_cast;

  assign final_phase =  phase_0 | phase_3 | phase_6 | phase_9;

  assign section_phase =  phase_0 | phase_6;

  assign accum_mux_in1_temp = (section_phase == 1'b1) ? sectionipconvert_cast :
                             accum_mux_in1;

  assign accum_mux_out = (final_phase == 1'b1) ? accum_mux_in1_temp :
                        accum_mux_in2;

  always @ (posedge i_clk or negedge i_reset)
    begin: accumulator_reg_process
      if (i_reset == 1'b0) begin
        accum_reg <= 0;
      end
      else begin
        if (i_clk_enable == 1'b1) begin
          accum_reg <= accum_mux_out;
        end
      end
    end // accumulator_reg_process

  assign add_cast = accum_reg;
  assign add_cast_1 = accum_mux_in1;
  assign add_temp = add_cast + add_cast_1;
  assign acc_sum = (add_temp[41] == 1'b0 & add_temp[40] != 1'b0) ? 41'b01111111111111111111111111111111111111111 : 
      (add_temp[41] == 1'b1 && add_temp[40] != 1'b1) ? 41'b10000000000000000000000000000000000000000 : add_temp[40:0];

  assign storagetypeconvert = (accum_mux_out[40] == 1'b0 & accum_mux_out[39:35] != 5'b00000) ? 32'b01111111111111111111111111111111 : 
      (accum_mux_out[40] == 1'b1 && accum_mux_out[39:35] != 5'b11111) ? 32'b10000000000000000000000000000000 : accum_mux_out[35:4];

  assign sectionipconvert = (prod[60] == 1'b0 & prod[59:51] != 9'b000000000) ? 32'b01111111111111111111111111111111 : 
      (prod[60] == 1'b1 && prod[59:51] != 9'b111111111) ? 32'b10000000000000000000000000000000 : prod[51:20];

  assign sectionipconvert_cast = $signed({sectionipconvert, 4'b0000});

  assign acc_out_cast_numacc = accum_mux_out[40:1];

  assign sectionopconvert = (acc_out_cast_numacc[39] == 1'b0 & acc_out_cast_numacc[38:34] != 5'b00000) ? 32'b01111111111111111111111111111111 : 
      (acc_out_cast_numacc[39] == 1'b1 && acc_out_cast_numacc[38:34] != 5'b11111) ? 32'b10000000000000000000000000000000 : acc_out_cast_numacc[34:3];

  assign output_typeconvert = (acc_out_cast_numacc[39] == 1'b0 & acc_out_cast_numacc[38:34] != 5'b00000) ? 32'b01111111111111111111111111111111 : 
      (acc_out_cast_numacc[39] == 1'b1 && acc_out_cast_numacc[38:34] != 5'b11111) ? 32'b10000000000000000000000000000000 : acc_out_cast_numacc[34:3];

  always @ (posedge i_clk or negedge i_reset)
    begin: storage_reg1_process
      if (i_reset == 1'b0) begin
        storage_state_in1 <= 0;
      end
      else begin
        if (phase_2 == 1'b1) begin
          storage_state_in1 <= storagetypeconvert;
        end
      end
    end // storage_reg1_process

  always @ (posedge i_clk or negedge i_reset)
    begin: storage_reg2_process
      if (i_reset == 1'b0) begin
        storage_state_in2 <= 0;
      end
      else begin
        if (phase_8 == 1'b1) begin
          storage_state_in2 <= storagetypeconvert;
        end
      end
    end // storage_reg2_process

  always @ (posedge i_clk or negedge i_reset)
    begin: Output_Register_process
      if (i_reset == 1'b0) begin
        output_register <= 0;
      end
      else begin
        if (phase_11 == 1'b1) begin
          output_register <= output_typeconvert;
        end
      end
    end // Output_Register_process

  // Assignment Statements
  assign o_filter_data = output_register;
endmodule  // IIR_filter
